import 'dart:io';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:firebase_storage/firebase_storage.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path/path.dart' as path;
import 'package:video_player/video_player.dart';
import '../models/video.dart';
import '../models/comment.dart';
import 'package:ffmpeg_kit_flutter/ffmpeg_kit.dart';
import 'package:path_provider/path_provider.dart';

class VideoService {
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Add getter for firestore
  FirebaseFirestore get firestore => _firestore;

  Future<Video> uploadVideo({
    required XFile videoFile,
    required String title,
    required String description,
    required List<String> tags,
    void Function(double)? onProgress,
  }) async {
    try {
      print('Starting video upload process...');
      print('File path: ${videoFile.path}');

      final user = _auth.currentUser;
      if (user == null) throw Exception('User must be logged in to upload videos');
      print('User authenticated: ${user.uid}');

      // 1. Upload video file to Storage
      final videoFileName = '${DateTime.now().millisecondsSinceEpoch}_${path.basename(videoFile.path)}';
      print('Generated filename: $videoFileName');

      final videoRef = _storage.ref().child('videos/$videoFileName');
      print('Storage reference created');

      UploadTask uploadTask;
      if (kIsWeb) {
        final bytes = await videoFile.readAsBytes();
        uploadTask = videoRef.putData(bytes, SettableMetadata(
          contentType: 'video/mp4',
        ));
      } else {
        uploadTask = videoRef.putFile(File(videoFile.path), SettableMetadata(
          contentType: 'video/mp4',
        ));
      }
      print('Upload task started');

      // Monitor upload progress
      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {
        final progress = (snapshot.bytesTransferred / snapshot.totalBytes);
        onProgress?.call(progress);
        print('Upload progress: ${(progress * 100).toStringAsFixed(2)}%');
      }, onError: (error) {
        print('Upload error: $error');
      });

      final snapshot = await uploadTask;
      print('Upload completed');

      final videoUrl = await snapshot.ref.getDownloadURL();
      print('Video URL obtained: $videoUrl');

      // The thumbnail will be generated by the cloud function and stored in thumbnails/[videoFileName]
      // We'll create a reference to where it will be stored
      final thumbnailRef = _storage.ref().child('thumbnails/$videoFileName.jpg');
      
      // 2. Create video document in Firestore
      print('Creating Firestore document...');
      final videoDoc = await _firestore.collection('videos').add({
        'title': title,
        'description': description,
        'videoUrl': videoUrl,
        'thumbnailUrl': '', // Will be updated by the cloud function
        'creatorId': user.uid,
        'creatorUsername': user.displayName ?? 'Anonymous',
        'tags': tags,
        'createdAt': FieldValue.serverTimestamp(),
        'likeCount': 0,
        'commentCount': 0,
        'viewCount': 0,
      });
      print('Firestore document created with ID: ${videoDoc.id}');

      // 3. Wait for thumbnail to be generated (with timeout)
      print('Waiting for thumbnail generation...');
      bool thumbnailGenerated = false;
      String thumbnailUrl = '';
      
      for (int i = 0; i < 10; i++) { // Try for 10 seconds
        try {
          thumbnailUrl = await thumbnailRef.getDownloadURL();
          thumbnailGenerated = true;
          break;
        } catch (e) {
          await Future.delayed(const Duration(seconds: 1));
        }
      }

      if (thumbnailGenerated) {
        print('Thumbnail generated: $thumbnailUrl');
        await videoDoc.update({'thumbnailUrl': thumbnailUrl});
      } else {
        print('Thumbnail generation timed out, using default thumbnail');
        // Use video URL as fallback
        await videoDoc.update({'thumbnailUrl': videoUrl});
      }

      // 4. Fetch the updated document
      final docSnapshot = await videoDoc.get();
      print('Upload process completed successfully');
      
      return Video.fromFirestore(docSnapshot);
    } catch (e, stackTrace) {
      print('Error during video upload: $e');
      print('Stack trace: $stackTrace');
      throw Exception('Failed to upload video: $e');
    }
  }

  Future<String> _generateThumbnail(File videoFile) async {
    try {
      // Initialize video controller
      final controller = VideoPlayerController.file(videoFile);
      await controller.initialize();
      
      // TODO: Generate actual thumbnail from video frame
      // For now, we'll return an empty string
      controller.dispose();
      return '';
    } catch (e) {
      return '';
    }
  }

  Future<void> deleteVideo(String videoId) async {
    if (_auth.currentUser == null) {
      throw 'User must be logged in to delete videos';
    }

    try {
      // Get the video document
      final videoDoc = await _firestore.collection('videos').doc(videoId).get();
      if (!videoDoc.exists) {
        throw 'Video not found';
      }

      final videoData = videoDoc.data()!;
      
      // Check if the user owns this video
      if (videoData['creatorId'] != _auth.currentUser!.uid) {
        throw 'You do not have permission to delete this video';
      }

      // Delete the video file from storage
      final videoUrl = videoData['videoUrl'] as String;
      final storageRef = _storage.refFromURL(videoUrl);
      await storageRef.delete();

      // Delete the thumbnail if it exists
      final thumbnailUrl = videoData['thumbnailUrl'] as String;
      if (thumbnailUrl.isNotEmpty) {
        final thumbnailRef = _storage.refFromURL(thumbnailUrl);
        await thumbnailRef.delete();
      }

      // Delete the video document
      await videoDoc.reference.delete();
    } catch (e) {
      throw 'Failed to delete video: $e';
    }
  }

  Stream<QuerySnapshot> getVideosForUser(String userId) {
    return _firestore
        .collection('videos')
        .where('creatorId', isEqualTo: userId)
        .orderBy('createdAt', descending: true)
        .snapshots();
  }

  Stream<QuerySnapshot> getAllVideos() {
    return _firestore
        .collection('videos')
        .orderBy('createdAt', descending: true)
        .snapshots();
  }

  Stream<QuerySnapshot> getVideosByTag(String tag) {
    return _firestore
        .collection('videos')
        .where('tags', arrayContains: tag)
        .orderBy('createdAt', descending: true)
        .snapshots();
  }

  // Fetch videos for the feed
  Stream<List<Video>> getVideoFeed() {
    return _firestore
        .collection('videos')
        .orderBy('createdAt', descending: true)  // Latest videos first
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => Video.fromFirestore(doc)).toList());
  }

  // Increment view count
  Future<void> incrementViewCount(String videoId) async {
    await _firestore.collection('videos').doc(videoId).update({
      'viewCount': FieldValue.increment(1),
    });
  }

  // Get current user's videos
  Future<List<Video>> getUserVideos() async {
    final user = _auth.currentUser;
    if (user == null) {
      throw Exception('User must be logged in to fetch their videos');
    }

    final snapshot = await _firestore
        .collection('videos')
        .where('creatorId', isEqualTo: user.uid)
        .orderBy('createdAt', descending: true)
        .get();

    return snapshot.docs.map((doc) => Video.fromFirestore(doc)).toList();
  }

  // Search videos by title, description, or tags
  Future<List<Video>> searchVideos({String? query, String? tag}) async {
    Query videosQuery = _firestore.collection('videos');

    // If tag is provided, filter by tag
    if (tag != null) {
      videosQuery = videosQuery.where('tags', arrayContains: tag);
    }

    // If search query is provided, filter by title or description
    if (query != null && query.isNotEmpty) {
      // Convert query to lowercase for case-insensitive search
      final lowercaseQuery = query.toLowerCase();
      videosQuery = videosQuery.where('title', isGreaterThanOrEqualTo: lowercaseQuery)
          .where('title', isLessThan: lowercaseQuery + 'z');
    }

    // Order by creation date
    videosQuery = videosQuery.orderBy('createdAt', descending: true);

    final snapshot = await videosQuery.get();
    return snapshot.docs.map((doc) => Video.fromFirestore(doc)).toList();
  }

  // Like/Unlike a video
  Future<void> toggleLike(String videoId) async {
    final user = _auth.currentUser;
    if (user == null) throw Exception('User must be logged in to like videos');

    final likeRef = _firestore
        .collection('videos')
        .doc(videoId)
        .collection('likes')
        .doc(user.uid);

    final likeDoc = await likeRef.get();
    
    await _firestore.runTransaction((transaction) async {
      final videoRef = _firestore.collection('videos').doc(videoId);
      final videoDoc = await transaction.get(videoRef);

      if (!videoDoc.exists) throw Exception('Video not found');

      if (likeDoc.exists) {
        // Unlike
        transaction.delete(likeRef);
        transaction.update(videoRef, {
          'likeCount': FieldValue.increment(-1),
        });
      } else {
        // Like
        transaction.set(likeRef, {
          'userId': user.uid,
          'createdAt': FieldValue.serverTimestamp(),
        });
        transaction.update(videoRef, {
          'likeCount': FieldValue.increment(1),
        });
      }
    });
  }

  // Check if user has liked a video
  Stream<bool> hasLiked(String videoId) {
    final user = _auth.currentUser;
    if (user == null) return Stream.value(false);

    return _firestore
        .collection('videos')
        .doc(videoId)
        .collection('likes')
        .doc(user.uid)
        .snapshots()
        .map((doc) => doc.exists);
  }

  // Add a comment to a video
  Future<Comment> addComment(String videoId, String text) async {
    final user = _auth.currentUser;
    if (user == null) {
      throw Exception('User must be logged in to comment');
    }

    try {
      // Create the comment document
      final commentDoc = await _firestore
          .collection('videos')
          .doc(videoId)
          .collection('comments')
          .add({
        'videoId': videoId,
        'userId': user.uid,
        'username': user.displayName ?? 'Anonymous',
        'userPhotoUrl': user.photoURL,
        'text': text,
        'createdAt': FieldValue.serverTimestamp(),
        'likeCount': 0,
        'likedBy': [],
      });

      // Increment comment count on the video
      await _firestore.collection('videos').doc(videoId).update({
        'commentCount': FieldValue.increment(1),
      });

      // Fetch the created comment
      final snapshot = await commentDoc.get();
      return Comment.fromFirestore(snapshot);
    } catch (e) {
      throw Exception('Failed to add comment: $e');
    }
  }

  // Get comments for a video
  Stream<List<Comment>> getVideoComments(String videoId) {
    return _firestore
        .collection('videos')
        .doc(videoId)
        .collection('comments')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => 
            snapshot.docs.map((doc) => Comment.fromFirestore(doc)).toList());
  }

  // Delete a comment
  Future<void> deleteComment(String videoId, String commentId) async {
    final user = _auth.currentUser;
    if (user == null) {
      throw Exception('User must be logged in to delete comments');
    }

    try {
      // Get the comment document
      final commentDoc = await _firestore
          .collection('videos')
          .doc(videoId)
          .collection('comments')
          .doc(commentId)
          .get();

      if (!commentDoc.exists) {
        throw Exception('Comment not found');
      }

      final commentData = commentDoc.data()!;
      
      // Check if the user owns this comment or the video
      final videoDoc = await _firestore.collection('videos').doc(videoId).get();
      final videoData = videoDoc.data()!;
      
      if (commentData['userId'] != user.uid && videoData['creatorId'] != user.uid) {
        throw Exception('You do not have permission to delete this comment');
      }

      // Delete the comment
      await commentDoc.reference.delete();

      // Decrement comment count on the video
      await _firestore.collection('videos').doc(videoId).update({
        'commentCount': FieldValue.increment(-1),
      });
    } catch (e) {
      throw Exception('Failed to delete comment: $e');
    }
  }

  // Toggle like on a comment
  Future<void> toggleCommentLike(String videoId, String commentId) async {
    final user = _auth.currentUser;
    if (user == null) {
      throw Exception('User must be logged in to like comments');
    }

    final commentRef = _firestore
        .collection('videos')
        .doc(videoId)
        .collection('comments')
        .doc(commentId);

    try {
      await _firestore.runTransaction((transaction) async {
        final commentDoc = await transaction.get(commentRef);
        
        if (!commentDoc.exists) {
          throw Exception('Comment not found');
        }

        final likedBy = List<String>.from(commentDoc.data()!['likedBy'] ?? []);
        
        if (likedBy.contains(user.uid)) {
          // Unlike
          likedBy.remove(user.uid);
          transaction.update(commentRef, {
            'likeCount': FieldValue.increment(-1),
            'likedBy': likedBy,
          });
        } else {
          // Like
          likedBy.add(user.uid);
          transaction.update(commentRef, {
            'likeCount': FieldValue.increment(1),
            'likedBy': likedBy,
          });
        }
      });
    } catch (e) {
      throw Exception('Failed to toggle comment like: $e');
    }
  }

  // Check if user has liked a comment
  Stream<bool> hasLikedComment(String videoId, String commentId) {
    final user = _auth.currentUser;
    if (user == null) return Stream.value(false);

    return _firestore
        .collection('videos')
        .doc(videoId)
        .collection('comments')
        .doc(commentId)
        .snapshots()
        .map((doc) => 
            doc.exists && 
            (doc.data()?['likedBy'] as List<dynamic>?)?.contains(user.uid) == true);
  }
} 